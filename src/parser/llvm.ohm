LLVM {
  Module = TopLevel*

  TopLevel = Function | (~"define" any)+

  // Loose parsing for function definition:
  // "define" [stuff] @Name ( [params] ) [stuff] { ... }
  Function = "define" FuncHeader GlobalValue "(" Params? ")" FuncAttrs "{" EntryBasicBlock BasicBlock* "}"

  // Consumes everything up to the GlobalValue (function name).
  // The last element is inherently the Return Type.
  FuncHeader = (~GlobalValue (type | id | any))*
  
  // Consumes everything after ')' and before '{'
  FuncAttrs = (~"{" any)*

  EntryBasicBlock = Label? Instruction* Terminator
  BasicBlock = Label Instruction* Terminator
  
  Label = id ":"
  
  Instruction = 
    | AssignInstruction
    | GenericInstruction
    
  AssignInstruction = LocalValue "=" opcode args metadata?
  
  GenericInstruction = opcode args metadata?
  
  opcode = ~"br" ~"ret" id
  
  // args consumes everything until metadata or newline
  // Lexical rule (lowercase) ensures we don't skip newlines implicitly
  args = (~metadata ~"\n" any)*

  // metadata: optional comma, then !, then rest of line
  metadata = ","? space* "!" (~"\n" any)+

  Terminator = 
    | BrInstruction
    | RetInstruction
    
  BrInstruction = "br" args metadata?
  RetInstruction = "ret" args metadata?
  
  // Lexical rules
  id = (letter | digit | "_" | ".")+
  
  GlobalValue = "@" id
  LocalValue = "%" id
  
  // Type can be significantly more complex, but we keep it somewhat simple for now.
  // Lowercase to avoid space insertion inside types like 'i 32'
  type = (letter | digit | "[" | "]" | "x" | "*" | "{" | "}" | "<" | ">" | "(" | ")" | "=" | "," | ".")+
  
  Value = GlobalValue | LocalValue | digit+
  
  Params = Param ("," Param)*
  
  // Param: type [attributes...] Value?
  Param = type ParamAttr* Value?
  ParamAttr = ~Value id

  space += comment
  comment = ";" (~"\n" any)*
}
