LLVM {
  Module = Function+
  
  // Loose parsing for function definition:
  // "define" [stuff] @Name ( [params] ) [stuff] { ... }
  Function = "define" FuncHeader GlobalValue "(" Params? ")" FuncAttrs "{" EntryBasicBlock BasicBlock* "}"

  // Consumes everything up to the GlobalValue (function name).
  // The last element is inherently the Return Type.
  FuncHeader = (~GlobalValue (Type | id | any))*
  
  // Consumes everything after ')' and before '{'
  FuncAttrs = (~"{" any)*

  EntryBasicBlock = Label? Instruction* Terminator
  BasicBlock = Label Instruction* Terminator
  
  Label = id ":"
  
  Instruction = 
    | AssignInstruction
    | StoreInstruction
    | CallInstruction
    | GenericInstruction
    
  AssignInstruction = LocalValue "=" invoke_op
  StoreInstruction = "store" invoke_op
  CallInstruction = ("call" | "tail call") invoke_op

  // A catch-all for instructions that are not terminators
  // use `~` to ensure we don't consume terminators or start of next block or function
  GenericInstruction = ~Terminator ~"}" ~Label (~"\n" any)+
  
  Terminator = 
    | BrCond
    | BrUncond
    | Ret
    
  BrCond = "br" Type Value "," "label" Value "," "label" Value
  BrUncond = "br" "label" Value
  Ret = "ret" Type Value
  
  // Lexical rules
  id = (letter | digit | "_" | ".")+
  
  GlobalValue = "@" id
  LocalValue = "%" id
  
  // Type can be significantly more complex, but we keep it somewhat simple for now.
  // Expanded to include loose tokens that might appear in types or attrs.
  Type = (letter | digit | "[" | "]" | "x" | "*" | "{" | "}" | "<" | ">" | "(" | ")" | "=" | "," | ".")+
  
  Value = GlobalValue | LocalValue | digit+
  
  Params = Param ("," Param)*
  
  // Param: Type [attributes...] Value?
  // We need to capture attributes.
  // ParamAttr = ~Value (id | digit+) -- any identifier/keyword not matching Value(%)
  Param = Type ParamAttr* Value?
  ParamAttr = ~Value id

  invoke_op = (~"\n" any)+

  space += comment
  comment = ";" (~"\n" any)*
}
