LLVM {
  LLVM = Module

  // Lexical rules
  ident = (letter | digit | "$" | "." | "_")+
  stringLiteral = "\"" (~"\"" any)* "\""
  type = (letter | digit | "[" | "]" | "x" | "*" | "{" | "}" | "<" | ">" | "(" | ")" | "=" | "," | ".")+
  metadata = ","? space* "!" (~"\n" any)+
  comment = ";" (~"\n" any)*
  space += comment

  Module = TopLevel*
  TopLevel = Function | (~"define" any)+

  // Function
  Function = "define" FuncHeader GlobalValue "(" Params? ")" FuncAttrs "{" EntryBasicBlock BasicBlock* "}"
  FuncHeader = (~GlobalValue any)*
  FuncAttrs = (~"{" any)*
  Params = Param ("," Param)*
  Param = (~(LocalValue &ParamTerminator) ~")" any)* LocalValue
  ParamTerminator = "," | ")"

  EntryBasicBlock = Label? Instruction* Terminator
  BasicBlock = Label Instruction* Terminator
  
  Label = ident ":"
  
  Instruction = 
    | AssignInstruction
    | GenericInstruction
    
  AssignInstruction = LocalValue "=" opcode args metadata?
  
  GenericInstruction = opcode args metadata?
  
  opcode = ~"br" ~"ret" ident
  
  // args consumes everything until metadata or newline
  // Lexical rule (lowercase) ensures we don't skip newlines implicitly
  args = (~metadata ~"\n" any)*

  // metadata: optional comma, then !, then rest of line

  Terminator = 
    | BrInstruction
    | RetInstruction
    
  BrInstruction = "br" args metadata?
  RetInstruction = "ret" args metadata?

  GlobalValue = "@" (ident | stringLiteral)
  LocalValue = "%" (ident | stringLiteral)
  Value = GlobalValue | LocalValue | digit+
}
